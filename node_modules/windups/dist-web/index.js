import React, { useReducer, useRef, useCallback, useEffect, useMemo, useContext, isValidElement } from 'react';
import breakLines from 'break-styled-lines';

function isPlayedWindup(windup) {
    return windup.length === 2;
}
function memberIsWindup(member) {
    // If it's not an array it can't be a windup
    if (!Array.isArray(member)) {
        return false;
    }
    // If it has less or more than three members it's not a windup
    if (member.length !== 3) {
        return false;
    }
    // If its first or second members are not arrays it's not a windup
    if (!Array.isArray(member[0]) || !Array.isArray(member[1])) {
        return false;
    }
    // Past here we just have to hope ElementType isn't a windup.
    return true;
}
function windupFromString(str, metadata) {
    return [[], str.split(""), metadata];
}
function newWindup(arg, metadata) {
    return [[], arg, metadata];
}
function isUnplayed(windup) {
    const [played, remaining] = windup;
    if (played.length > 0) {
        return false;
    }
    return remaining.reduce((unplayed, member) => {
        if (memberIsWindup(member))
            if (memberIsWindup(windup) && unplayed) {
                return isUnplayed(member);
            }
        return unplayed;
    }, true);
}
function isFinished([_played, remaining,]) {
    return remaining.length === 0;
}
function fastForward(windup) {
    const forwardedWindup = next(windup);
    if (isFinished(forwardedWindup)) {
        return forwardedWindup;
    }
    return fastForward(forwardedWindup);
}
function rewind(windup) {
    if (isUnplayed(windup)) {
        return windup;
    }
    const [played, remaining, metadata] = windup;
    const mapRewind = (member) => {
        if (memberIsWindup(member)) {
            return rewind(member);
        }
        return member;
    };
    return [
        [],
        [...played.map(mapRewind), ...remaining.map(mapRewind)],
        metadata,
    ];
}
function lastPlayedMember([played, remaining,]) {
    const playedFromRemaining = remaining.reduce((playedEl, member) => {
        if (memberIsWindup(member)) {
            if (!isUnplayed(member)) {
                return lastPlayedElement(member);
            }
        }
        return playedEl;
    }, undefined);
    if (playedFromRemaining) {
        return playedFromRemaining;
    }
    const last = played[played.length - 1];
    return last;
}
function lastPlayedElement(windup) {
    const lastPlayed = lastPlayedMember(windup);
    if (memberIsWindup(lastPlayed)) {
        return lastPlayedElement(lastPlayed);
    }
    return lastPlayed;
}
function playedElements([played, remaining,]) {
    const playedTransformed = played.map((member) => {
        if (memberIsWindup(member)) {
            const [_played, _remaining, metadata] = member;
            return [playedElements(member), metadata];
        }
        return member;
    });
    const [firstRemaning] = remaining;
    if (memberIsWindup(firstRemaning) && !isUnplayed(firstRemaning)) {
        const [_playedRemaining, _remaining, metadata] = firstRemaning;
        return [
            ...playedTransformed,
            [playedElements(firstRemaning), metadata],
        ];
    }
    return playedTransformed;
}
function nextElement([_played, remaining,]) {
    const [nextVal] = remaining;
    if (memberIsWindup(nextVal)) {
        return nextElement(nextVal);
    }
    return nextVal;
}
function next(windup) {
    // start
    // [[], [[[], ["h", "i"]], [[], ["n", "o"]]]]
    // next
    // [[], [[["h"], ["i"]], ["", ["n", "o"]]]]
    // next
    // [["h", "i"], [["n", "o"]]]
    // next
    // [["h", "i"] ["n", "o"]], []]
    if (isFinished(windup)) {
        return windup;
    }
    const [played, remaining, metadata] = windup;
    const [firstRemaining, ...restRemaining] = remaining;
    if (memberIsWindup(firstRemaining)) {
        const nextFirstRemaining = next(firstRemaining);
        if (isFinished(nextFirstRemaining)) {
            return [[...played, nextFirstRemaining], restRemaining, metadata];
        }
        return [played, [nextFirstRemaining, ...restRemaining], metadata];
    }
    return [[...played, firstRemaining], restRemaining, metadata];
}

function defaultGetPace(lastChar, nextChar) {
    switch (lastChar) {
        case "—":
        case "…":
            return 200;
        case ".":
        case ",":
            return 150;
        case "?":
        case "!":
            if (nextChar !== "!" && nextChar !== "?") {
                return 150;
            }
        case "-":
        case " ":
        case "\n":
            return 0;
        default:
            return 20;
    }
}
const Pace = ({ children }) => {
    return React.createElement(React.Fragment, null, children);
};
function isPaceElement(element) {
    return element.type === Pace;
}
function isMsProp(props) {
    if ("ms" in props) {
        return true;
    }
    return false;
}
function paceFromWindup(windup) {
    if (isFinished(windup)) {
        return undefined;
    }
    const [_played, remaining, metadata] = windup;
    const [firstRemaining] = remaining;
    if (firstRemaining && memberIsWindup(firstRemaining)) {
        return paceFromWindup(firstRemaining);
    }
    return metadata.pace;
}

const OnChar = ({ children }) => {
    return React.createElement(React.Fragment, null, children);
};
function isOnCharElement(element) {
    return element.type === OnChar;
}
// Should return onChars from
// every just played member that is a windup
// any first remaining that is played
function onCharsFromWindup(windup) {
    const [_played, remaining, metadata] = windup;
    const lastPlayed = lastPlayedMember(windup);
    const [firstRemaining] = remaining;
    let onChars = [];
    if (lastPlayed && memberIsWindup(lastPlayed)) {
        onChars.push(...onCharsFromWindup(lastPlayed));
    }
    if (firstRemaining &&
        memberIsWindup(firstRemaining) &&
        !isUnplayed(firstRemaining)) {
        onChars.push(...onCharsFromWindup(firstRemaining));
    }
    if (metadata.onChar) {
        onChars.push(metadata.onChar);
    }
    return onChars;
}

function initWindupState(windup) {
    return { windup, didFinishOnce: false };
}
function windupReducer(state, action) {
    switch (action.type) {
        case "replace":
            return initWindupState(action.windup);
        case "next":
            return { ...state, windup: next(state.windup) };
        case "rewind":
            return { windup: rewind(state.windup), didFinishOnce: false };
        case "fast-forward":
            return { ...state, windup: fastForward(state.windup) };
        case "finish":
            return { ...state, didFinishOnce: true };
        default:
            return state;
    }
}
function useWindup(windupInit, options) {
    const [{ windup, didFinishOnce }, dispatch] = useReducer(windupReducer, windupInit, initWindupState);
    const timeoutRef = useRef(null);
    const windupIsFinished = isFinished(windup);
    const skip = useCallback(() => {
        if (!windupIsFinished) {
            if (timeoutRef.current) {
                clearTimeout(timeoutRef.current);
            }
            dispatch({
                type: "fast-forward",
            });
        }
    }, [windupIsFinished]);
    const rewind = useCallback(() => {
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }
        dispatch({ type: "rewind" });
    }, []);
    // If windup arg changes, we should reset
    useEffect(() => {
        dispatch({ type: "replace", windup: windupInit });
    }, [windupInit]);
    // If skipped is changes to true, we should skip
    // And if it's changed to false, we should restart
    useEffect(() => {
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }
        if (options.skipped) {
            dispatch({
                type: "fast-forward",
            });
        }
        if (options.skipped === false) {
            dispatch({ type: "rewind" });
        }
    }, [options.skipped]);
    // When the windup changes, onChar should fire
    useEffect(() => {
        const onChars = onCharsFromWindup(windup);
        const lastEl = lastPlayedElement(windup);
        if (onChars.length > 0 && lastEl) {
            onChars.forEach((onChar) => {
                onChar(lastEl);
            });
        }
    }, [windup]);
    // If windup finishes, the onFinished should fire
    useEffect(() => {
        // Put this in a new context so that the windup finishes visually before firing this
        if (didFinishOnce === false && windupIsFinished) {
            const timeout = setTimeout(() => {
                if (options.onFinished) {
                    options.onFinished();
                }
                dispatch({ type: "finish" });
            }, 0);
            return () => {
                clearTimeout(timeout);
            };
        }
    }, [didFinishOnce, windupIsFinished, options]);
    // the windup effect itself
    useEffect(() => {
        if (!windupIsFinished) {
            const getPace = paceFromWindup(windup) || defaultGetPace;
            const lastEl = lastPlayedElement(windup);
            const nextEl = nextElement(windup);
            timeoutRef.current = setTimeout(() => {
                dispatch({ type: "next" });
            }, lastEl ? getPace(lastEl, nextEl) : 0);
            return () => {
                if (timeoutRef.current) {
                    clearTimeout(timeoutRef.current);
                }
            };
        }
    }, [windup, windupIsFinished]);
    return {
        windup,
        skip,
        rewind,
        isFinished: windupIsFinished,
    };
}

function renderStringWindup(windup) {
    const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);
    const inner = played.reduce((acc, playedEl) => {
        if (typeof playedEl === "string") {
            return acc + playedEl;
        }
        return acc + renderStringWindup(playedEl);
    }, "");
    return inner;
}
const VOID_TAGS = [
    "area",
    "base",
    "br",
    "col",
    "command",
    "embed",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
];
function renderChildrenWindup(windup) {
    const metadata = isPlayedWindup(windup) ? windup[1] : windup[2];
    const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);
    const Outer = metadata.element || React.Fragment;
    if (metadata.props && Object.keys(metadata.props).includes("children")) {
        return React.createElement(Outer, Object.assign({}, metadata.props));
    }
    const inner = played.reduce((acc, playedEl) => {
        if (typeof playedEl === "string") {
            const accButLast = acc.slice(0, acc.length - 1);
            const last = acc[acc.length - 1];
            return last && typeof last === "string"
                ? [...accButLast, last + playedEl]
                : [...acc, playedEl];
        }
        return [...acc, renderChildrenWindup(playedEl)];
    }, []);
    if (typeof metadata.element === "string" &&
        VOID_TAGS.includes(metadata.element)) {
        return React.createElement(Outer, Object.assign({ key: metadata.key }, metadata.props));
    }
    return (React.createElement(Outer, Object.assign({ key: metadata.key }, metadata.props), inner));
}

function useWindupString(text, options = {}) {
    const windupInit = useMemo(() => {
        return windupFromString(text, options);
    }, [text]);
    const { windup, skip, rewind, isFinished } = useWindup(windupInit, options);
    return [renderStringWindup(windup), { skip, rewind, isFinished }];
}

const Pause = ({}) => {
    return null;
};
function isPauseElement(element) {
    return element.type === Pause;
}

const WindupContext = React.createContext({
    skip: () => {
        console.warn("Tried to use the useSkip hook outside of a WindupChildren component!!");
    },
    rewind: () => {
        console.warn("Tried to use the useRewind hook outside of a WindupChildren component!");
    },
    isFinished: false
});
function useSkip() {
    const { skip } = useContext(WindupContext);
    return skip;
}
function useRewind() {
    const { rewind } = useContext(WindupContext);
    return rewind;
}
function useIsFinished() {
    const { isFinished } = useContext(WindupContext);
    return isFinished;
}
function reduceWindupArgs(prevArgs, children) {
    if (typeof children === "string") {
        return [...prevArgs, ...children.split("")];
    }
    if (typeof children === "number") {
        return [...prevArgs, ...children.toString().split("")];
    }
    if (!React.isValidElement(children)) {
        return prevArgs;
    }
    const { children: childrenChildren, ...restProps } = children.props;
    const paceMetaData = isPaceElement(children)
        ? {
            pace: (char) => {
                if (isMsProp(children.props)) {
                    return children.props.ms;
                }
                return children.props.getPace(char);
            }
        }
        : {};
    const onCharMetaData = isOnCharElement(children)
        ? {
            onChar: children.props.fn
        }
        : {};
    const keyProp = children.key ? { key: children.key } : {};
    if (isPauseElement(children)) {
        return [
            ...prevArgs,
            windupFromString(" ", {
                element: React.Fragment,
                ...keyProp,
                props: {},
                pace: () => children.props.ms
            })
        ];
    }
    if (childrenChildren === undefined) {
        return [
            ...prevArgs,
            windupFromString(" ", {
                element: children.type,
                props: restProps,
                ...keyProp,
                ...paceMetaData,
                ...onCharMetaData
            })
        ];
    }
    if (typeof childrenChildren === "string") {
        return [
            ...prevArgs,
            windupFromString(childrenChildren, {
                element: children.type,
                props: restProps,
                ...keyProp,
                ...paceMetaData,
                ...onCharMetaData
            })
        ];
    }
    if (childrenChildren instanceof Function) {
        return [
            ...prevArgs,
            windupFromString(" ", {
                element: children.type,
                props: { children: childrenChildren, ...restProps },
                ...keyProp,
                ...paceMetaData,
                ...onCharMetaData
            })
        ];
    }
    const newArgs = React.Children.toArray(childrenChildren).reduce(reduceWindupArgs, []);
    const argsWithMetadata = newArgs.map(member => {
        if (memberIsWindup(member)) {
            const [played, remaining, metadata] = member;
            return [
                played,
                remaining,
                {
                    ...paceMetaData,
                    ...onCharMetaData,
                    ...metadata
                }
            ];
        }
        return member;
    });
    return [
        ...prevArgs,
        newWindup(argsWithMetadata, {
            element: children.type,
            props: restProps,
            ...keyProp,
            ...paceMetaData,
            ...onCharMetaData
        })
    ];
}
function buildKeyString(children) {
    if (children === null || children === undefined) {
        return "";
    }
    return React.Children.map(children, child => {
        if (typeof child === "string") {
            return child;
        }
        if (typeof child === "number") {
            return child.toString();
        }
        if (React.isValidElement(child)) {
            return `#${child.key || ""}<${buildKeyString(child.props.children)}>`;
        }
        return "";
    }).join(",");
}
function useChildrenMemo(factory, children) {
    const memoChildren = useMemo(factory, [buildKeyString(children)]);
    return memoChildren;
}
const WindupChildren = ({ children, onFinished, skipped }) => {
    const windupInit = useChildrenMemo(() => {
        return newWindup(React.Children.toArray(children).reduce(reduceWindupArgs, []), { element: undefined });
    }, children);
    const { windup, skip, rewind, isFinished } = useWindup(windupInit, {
        onFinished,
        skipped
    });
    return (React.createElement(WindupContext.Provider, { value: {
            skip,
            rewind,
            isFinished
        } }, renderChildrenWindup(windup)));
};

function wrapChildren(children, Wrapper) {
    if (typeof children === "string") {
        return children
            .split("")
            .map((char, i) => char === "\n" ? char : React.createElement(Wrapper, { key: `${char}-${i}` }, char));
    }
    if (typeof children === "number") {
        return children
            .toString()
            .split("")
            .map(char => React.createElement(Wrapper, null, char));
    }
    if (!React.isValidElement(children)) {
        return React.createElement(React.Fragment, null);
    }
    if (children.props.children) {
        const Outer = children.type;
        if (children.props.children instanceof Function) {
            return React.createElement(Outer, Object.assign({ key: children.key }, children.props));
        }
        return (React.createElement(Outer, Object.assign({ key: children.key }, children.props), React.Children.map(children.props.children, ch => {
            return wrapChildren(ch, Wrapper);
        })));
    }
    return children;
}
const CharWrapper = ({ children, element }) => {
    return (React.createElement(React.Fragment, null, React.Children.map(children, ch => {
        return wrapChildren(ch, element);
    })));
};

function getStringsOfReactChildren(strings, children) {
    if (typeof children === "string") {
        return [...strings, children];
    }
    if (typeof children === "number") {
        return [...strings, children.toString()];
    }
    if (!React.isValidElement(children)) {
        return strings;
    }
    return [
        ...strings,
        ...React.Children.toArray(children.props.children).reduce(getStringsOfReactChildren, [])
    ];
}
function reinsertStringsIntoChildren([accChildren, accStrings], children) {
    if (typeof children === "string" || typeof children === "number") {
        const [firstString, ...restStrings] = accStrings;
        return [[...accChildren, firstString], restStrings];
    }
    if (!React.isValidElement(children)) {
        return [accChildren, accStrings];
    }
    const [subChildrenAcc, subStringsAcc] = React.Children.toArray(children.props.children).reduce(reinsertStringsIntoChildren, [[], accStrings]);
    return [
        [
            ...accChildren,
            React.cloneElement(children, {
                children: subChildrenAcc
            })
        ],
        subStringsAcc
    ];
}
const Linebreaker = ({ children, fontStyle, width }) => {
    // CAVEATS:
    // fontStyle must match the font style of the characters inside
    // non-character elements must not add width to the line.
    // must be used OUTSIDE of WindupChildren component
    const childrenArray = React.Children.toArray(children);
    const strings = childrenArray.reduce(getStringsOfReactChildren, []);
    const transformedStrings = breakLines(strings, width, fontStyle);
    const [transformedChildren] = childrenArray.reduce(reinsertStringsIntoChildren, [
        [],
        transformedStrings
    ]);
    return React.createElement("div", { style: { whiteSpace: "pre" } }, transformedChildren);
};

const Effect = ({ fn }) => {
    useEffect(() => {
        fn();
    }, []);
    return null;
};

function textFromChildren(children) {
    return React.Children.map(children, (ch) => {
        if (typeof ch === "string") {
            return ch;
        }
        if (typeof ch === "number") {
            return ch.toString();
        }
        if (!isValidElement(ch)) {
            return "";
        }
        if (ch.props.children) {
            return textFromChildren(ch.props.children);
        }
        return "";
    }).join("");
}

export { CharWrapper, Effect, Linebreaker, OnChar, Pace, Pause, WindupChildren, defaultGetPace, textFromChildren, useIsFinished, useRewind, useSkip, useWindupString };
//# sourceMappingURL=index.js.map
