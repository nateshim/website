{"version":3,"file":"index.js","sources":["../dist-src/break-lines.js"],"sourcesContent":["function isArray(text) {\n    return Array.isArray(text);\n}\nfunction insertNewlineAtPosition(position, arrayOfStrings) {\n    const { indexToInsertInto, localPosition } = arrayOfStrings.reduce(({ indexToInsertInto, localPosition, lengthOfPreceding }, string, i) => {\n        const totalLength = string.length + lengthOfPreceding;\n        if (!indexToInsertInto && !localPosition && position < totalLength) {\n            return {\n                indexToInsertInto: i,\n                localPosition: position - lengthOfPreceding,\n                lengthOfPreceding: totalLength\n            };\n        }\n        return {\n            indexToInsertInto,\n            localPosition,\n            lengthOfPreceding: totalLength\n        };\n    }, { indexToInsertInto: 0, localPosition: 0, lengthOfPreceding: 0 });\n    return (arrayOfStrings\n        .map((string, i) => {\n        if (i === indexToInsertInto) {\n            return (string.slice(0, localPosition) + \"\\n\" + string.slice(localPosition));\n        }\n        return string;\n    })\n        // This is to remove whitespace adjacent to newlines, but to preserve starting or trailing whitespace\n        .map(string => string\n        .split(\"\\n\")\n        .map((str, i, strs) => {\n        if (i < strs.length - 2 && i > 0) {\n            return str.trim();\n        }\n        if (i < strs.length - 2) {\n            return str.trimRight();\n        }\n        else if (i > 0) {\n            return str.trimLeft();\n        }\n        return str;\n    })\n        .join(\"\\n\")));\n}\nfunction breakLines(text, width, font) {\n    const supportsOffscreenCanvas = \"OffscreenCanvas\" in window;\n    const canvasEl = document.createElement(\"canvas\");\n    const canvas = supportsOffscreenCanvas\n        ? canvasEl.transferControlToOffscreen()\n        : canvasEl;\n    canvas.width = width;\n    const ctx = canvas.getContext(\"2d\");\n    if (ctx) {\n        ctx.font = font;\n        const brokenWords = text.split(\" \").reduce((accumulator, word) => {\n            // get the last element of the accumulator\n            const [lastLine] = accumulator.slice(-1);\n            // add the word to it\n            const maybeNextLine = [...lastLine, word].join(\" \");\n            // see if it fits within the width\n            let { width: textWidth } = ctx.measureText(maybeNextLine);\n            // if it does, append to the last element\n            if (textWidth <= width) {\n                return [...accumulator.slice(0, -1), [...lastLine, word]];\n            }\n            if (lastLine.length === 0) {\n                return [...accumulator.slice(0, -1), [word]];\n            }\n            // if not, create a new array containing the word as the last element\n            return [...accumulator, [word]];\n        }, [[]]);\n        return brokenWords.map(line => line.join(\" \")).join(\"\\n\");\n    }\n    console.warn(\"No canvas context was found, so the string was left as is!\");\n    return text;\n}\n/**\n * Breaks a string into lines given a width and style for the text.\n *\n * @param string - The text to be broken into lines\n * @param width - The width in pixels for the text to fit into\n * @param font - The style of the text expressed as a value of the CSS font property, e.g. '12pt bold serif'\n * @returns The given string with newlines inserted\n */\nfunction breakLinesEntry(text, width, font) {\n    if (isArray(text)) {\n        /*\n          ['hello there ', 'my good friend, ', 'how are you today?']\n        + ['hello there my good\\n friend, how are you\\n today?']\n        = ['hello there ', 'my good\\n friend, ', 'how are you\\n today?']\n        */\n        const withNewLines = breakLines(text.join(\"\"), width, font);\n        const newLinePositions = withNewLines\n            .split(\"\")\n            .reduce((positions, char, i) => {\n            if (char === \"\\n\") {\n                return [...positions, i];\n            }\n            return positions;\n        }, []);\n        return newLinePositions.reduce((result, position) => {\n            return insertNewlineAtPosition(position, result);\n        }, text);\n    }\n    return breakLines(text, width, font);\n}\nexport default breakLinesEntry;\n"],"names":[],"mappings":"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"}