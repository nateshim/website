{"ast":null,"code":"function isArray(text) {\n  return Array.isArray(text);\n}\n\nfunction insertNewlineAtPosition(position, arrayOfStrings) {\n  const {\n    indexToInsertInto,\n    localPosition\n  } = arrayOfStrings.reduce(({\n    indexToInsertInto,\n    localPosition,\n    lengthOfPreceding\n  }, string, i) => {\n    const totalLength = string.length + lengthOfPreceding;\n\n    if (!indexToInsertInto && !localPosition && position < totalLength) {\n      return {\n        indexToInsertInto: i,\n        localPosition: position - lengthOfPreceding,\n        lengthOfPreceding: totalLength\n      };\n    }\n\n    return {\n      indexToInsertInto,\n      localPosition,\n      lengthOfPreceding: totalLength\n    };\n  }, {\n    indexToInsertInto: 0,\n    localPosition: 0,\n    lengthOfPreceding: 0\n  });\n  return arrayOfStrings.map((string, i) => {\n    if (i === indexToInsertInto) {\n      return string.slice(0, localPosition) + \"\\n\" + string.slice(localPosition);\n    }\n\n    return string;\n  }) // This is to remove whitespace adjacent to newlines, but to preserve starting or trailing whitespace\n  .map(string => string.split(\"\\n\").map((str, i, strs) => {\n    if (i < strs.length - 2 && i > 0) {\n      return str.trim();\n    }\n\n    if (i < strs.length - 2) {\n      return str.trimRight();\n    } else if (i > 0) {\n      return str.trimLeft();\n    }\n\n    return str;\n  }).join(\"\\n\"));\n}\n\nfunction breakLines(text, width, font) {\n  const supportsOffscreenCanvas = (\"OffscreenCanvas\" in window);\n  const canvasEl = document.createElement(\"canvas\");\n  const canvas = supportsOffscreenCanvas ? canvasEl.transferControlToOffscreen() : canvasEl;\n  canvas.width = width;\n  const ctx = canvas.getContext(\"2d\");\n\n  if (ctx) {\n    ctx.font = font;\n    const brokenWords = text.split(\" \").reduce((accumulator, word) => {\n      // get the last element of the accumulator\n      const [lastLine] = accumulator.slice(-1); // add the word to it\n\n      const maybeNextLine = [...lastLine, word].join(\" \"); // see if it fits within the width\n\n      let {\n        width: textWidth\n      } = ctx.measureText(maybeNextLine); // if it does, append to the last element\n\n      if (textWidth <= width) {\n        return [...accumulator.slice(0, -1), [...lastLine, word]];\n      }\n\n      if (lastLine.length === 0) {\n        return [...accumulator.slice(0, -1), [word]];\n      } // if not, create a new array containing the word as the last element\n\n\n      return [...accumulator, [word]];\n    }, [[]]);\n    return brokenWords.map(line => line.join(\" \")).join(\"\\n\");\n  }\n\n  console.warn(\"No canvas context was found, so the string was left as is!\");\n  return text;\n}\n/**\n * Breaks a string into lines given a width and style for the text.\n *\n * @param string - The text to be broken into lines\n * @param width - The width in pixels for the text to fit into\n * @param font - The style of the text expressed as a value of the CSS font property, e.g. '12pt bold serif'\n * @returns The given string with newlines inserted\n */\n\n\nfunction breakLinesEntry(text, width, font) {\n  if (isArray(text)) {\n    /*\n      ['hello there ', 'my good friend, ', 'how are you today?']\n    + ['hello there my good\\n friend, how are you\\n today?']\n    = ['hello there ', 'my good\\n friend, ', 'how are you\\n today?']\n    */\n    const withNewLines = breakLines(text.join(\"\"), width, font);\n    const newLinePositions = withNewLines.split(\"\").reduce((positions, char, i) => {\n      if (char === \"\\n\") {\n        return [...positions, i];\n      }\n\n      return positions;\n    }, []);\n    return newLinePositions.reduce((result, position) => {\n      return insertNewlineAtPosition(position, result);\n    }, text);\n  }\n\n  return breakLines(text, width, font);\n}\n\nexport default breakLinesEntry;","map":{"version":3,"sources":["../dist-src/break-lines.js"],"names":[],"mappings":"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","sourcesContent":["function isArray(text) {\n    return Array.isArray(text);\n}\nfunction insertNewlineAtPosition(position, arrayOfStrings) {\n    const { indexToInsertInto, localPosition } = arrayOfStrings.reduce(({ indexToInsertInto, localPosition, lengthOfPreceding }, string, i) => {\n        const totalLength = string.length + lengthOfPreceding;\n        if (!indexToInsertInto && !localPosition && position < totalLength) {\n            return {\n                indexToInsertInto: i,\n                localPosition: position - lengthOfPreceding,\n                lengthOfPreceding: totalLength\n            };\n        }\n        return {\n            indexToInsertInto,\n            localPosition,\n            lengthOfPreceding: totalLength\n        };\n    }, { indexToInsertInto: 0, localPosition: 0, lengthOfPreceding: 0 });\n    return (arrayOfStrings\n        .map((string, i) => {\n        if (i === indexToInsertInto) {\n            return (string.slice(0, localPosition) + \"\\n\" + string.slice(localPosition));\n        }\n        return string;\n    })\n        // This is to remove whitespace adjacent to newlines, but to preserve starting or trailing whitespace\n        .map(string => string\n        .split(\"\\n\")\n        .map((str, i, strs) => {\n        if (i < strs.length - 2 && i > 0) {\n            return str.trim();\n        }\n        if (i < strs.length - 2) {\n            return str.trimRight();\n        }\n        else if (i > 0) {\n            return str.trimLeft();\n        }\n        return str;\n    })\n        .join(\"\\n\")));\n}\nfunction breakLines(text, width, font) {\n    const supportsOffscreenCanvas = \"OffscreenCanvas\" in window;\n    const canvasEl = document.createElement(\"canvas\");\n    const canvas = supportsOffscreenCanvas\n        ? canvasEl.transferControlToOffscreen()\n        : canvasEl;\n    canvas.width = width;\n    const ctx = canvas.getContext(\"2d\");\n    if (ctx) {\n        ctx.font = font;\n        const brokenWords = text.split(\" \").reduce((accumulator, word) => {\n            // get the last element of the accumulator\n            const [lastLine] = accumulator.slice(-1);\n            // add the word to it\n            const maybeNextLine = [...lastLine, word].join(\" \");\n            // see if it fits within the width\n            let { width: textWidth } = ctx.measureText(maybeNextLine);\n            // if it does, append to the last element\n            if (textWidth <= width) {\n                return [...accumulator.slice(0, -1), [...lastLine, word]];\n            }\n            if (lastLine.length === 0) {\n                return [...accumulator.slice(0, -1), [word]];\n            }\n            // if not, create a new array containing the word as the last element\n            return [...accumulator, [word]];\n        }, [[]]);\n        return brokenWords.map(line => line.join(\" \")).join(\"\\n\");\n    }\n    console.warn(\"No canvas context was found, so the string was left as is!\");\n    return text;\n}\n/**\n * Breaks a string into lines given a width and style for the text.\n *\n * @param string - The text to be broken into lines\n * @param width - The width in pixels for the text to fit into\n * @param font - The style of the text expressed as a value of the CSS font property, e.g. '12pt bold serif'\n * @returns The given string with newlines inserted\n */\nfunction breakLinesEntry(text, width, font) {\n    if (isArray(text)) {\n        /*\n          ['hello there ', 'my good friend, ', 'how are you today?']\n        + ['hello there my good\\n friend, how are you\\n today?']\n        = ['hello there ', 'my good\\n friend, ', 'how are you\\n today?']\n        */\n        const withNewLines = breakLines(text.join(\"\"), width, font);\n        const newLinePositions = withNewLines\n            .split(\"\")\n            .reduce((positions, char, i) => {\n            if (char === \"\\n\") {\n                return [...positions, i];\n            }\n            return positions;\n        }, []);\n        return newLinePositions.reduce((result, position) => {\n            return insertNewlineAtPosition(position, result);\n        }, text);\n    }\n    return breakLines(text, width, font);\n}\nexport default breakLinesEntry;\n"]},"metadata":{},"sourceType":"module"}