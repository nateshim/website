{"ast":null,"code":"import _toConsumableArray from \"/Users/johnshim/Desktop/website/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/johnshim/Desktop/website/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction isArray(text) {\n  return Array.isArray(text);\n}\n\nfunction insertNewlineAtPosition(position, arrayOfStrings) {\n  var _arrayOfStrings$reduc = arrayOfStrings.reduce(function (_ref, string, i) {\n    var indexToInsertInto = _ref.indexToInsertInto,\n        localPosition = _ref.localPosition,\n        lengthOfPreceding = _ref.lengthOfPreceding;\n    var totalLength = string.length + lengthOfPreceding;\n\n    if (!indexToInsertInto && !localPosition && position < totalLength) {\n      return {\n        indexToInsertInto: i,\n        localPosition: position - lengthOfPreceding,\n        lengthOfPreceding: totalLength\n      };\n    }\n\n    return {\n      indexToInsertInto: indexToInsertInto,\n      localPosition: localPosition,\n      lengthOfPreceding: totalLength\n    };\n  }, {\n    indexToInsertInto: 0,\n    localPosition: 0,\n    lengthOfPreceding: 0\n  }),\n      indexToInsertInto = _arrayOfStrings$reduc.indexToInsertInto,\n      localPosition = _arrayOfStrings$reduc.localPosition;\n\n  return arrayOfStrings.map(function (string, i) {\n    if (i === indexToInsertInto) {\n      return string.slice(0, localPosition) + \"\\n\" + string.slice(localPosition);\n    }\n\n    return string;\n  }) // This is to remove whitespace adjacent to newlines, but to preserve starting or trailing whitespace\n  .map(function (string) {\n    return string.split(\"\\n\").map(function (str, i, strs) {\n      if (i < strs.length - 2 && i > 0) {\n        return str.trim();\n      }\n\n      if (i < strs.length - 2) {\n        return str.trimRight();\n      } else if (i > 0) {\n        return str.trimLeft();\n      }\n\n      return str;\n    }).join(\"\\n\");\n  });\n}\n\nfunction breakLines(text, width, font) {\n  var supportsOffscreenCanvas = (\"OffscreenCanvas\" in window);\n  var canvasEl = document.createElement(\"canvas\");\n  var canvas = supportsOffscreenCanvas ? canvasEl.transferControlToOffscreen() : canvasEl;\n  canvas.width = width;\n  var ctx = canvas.getContext(\"2d\");\n\n  if (ctx) {\n    ctx.font = font;\n    var brokenWords = text.split(\" \").reduce(function (accumulator, word) {\n      // get the last element of the accumulator\n      var _accumulator$slice = accumulator.slice(-1),\n          _accumulator$slice2 = _slicedToArray(_accumulator$slice, 1),\n          lastLine = _accumulator$slice2[0]; // add the word to it\n\n\n      var maybeNextLine = [].concat(_toConsumableArray(lastLine), [word]).join(\" \"); // see if it fits within the width\n\n      var _ctx$measureText = ctx.measureText(maybeNextLine),\n          textWidth = _ctx$measureText.width; // if it does, append to the last element\n\n\n      if (textWidth <= width) {\n        return [].concat(_toConsumableArray(accumulator.slice(0, -1)), [[].concat(_toConsumableArray(lastLine), [word])]);\n      }\n\n      if (lastLine.length === 0) {\n        return [].concat(_toConsumableArray(accumulator.slice(0, -1)), [[word]]);\n      } // if not, create a new array containing the word as the last element\n\n\n      return [].concat(_toConsumableArray(accumulator), [[word]]);\n    }, [[]]);\n    return brokenWords.map(function (line) {\n      return line.join(\" \");\n    }).join(\"\\n\");\n  }\n\n  console.warn(\"No canvas context was found, so the string was left as is!\");\n  return text;\n}\n/**\n * Breaks a string into lines given a width and style for the text.\n *\n * @param string - The text to be broken into lines\n * @param width - The width in pixels for the text to fit into\n * @param font - The style of the text expressed as a value of the CSS font property, e.g. '12pt bold serif'\n * @returns The given string with newlines inserted\n */\n\n\nfunction breakLinesEntry(text, width, font) {\n  if (isArray(text)) {\n    /*\n      ['hello there ', 'my good friend, ', 'how are you today?']\n    + ['hello there my good\\n friend, how are you\\n today?']\n    = ['hello there ', 'my good\\n friend, ', 'how are you\\n today?']\n    */\n    var withNewLines = breakLines(text.join(\"\"), width, font);\n    var newLinePositions = withNewLines.split(\"\").reduce(function (positions, char, i) {\n      if (char === \"\\n\") {\n        return [].concat(_toConsumableArray(positions), [i]);\n      }\n\n      return positions;\n    }, []);\n    return newLinePositions.reduce(function (result, position) {\n      return insertNewlineAtPosition(position, result);\n    }, text);\n  }\n\n  return breakLines(text, width, font);\n}\n\nexport default breakLinesEntry;","map":{"version":3,"sources":["../dist-src/break-lines.js"],"names":[],"mappings":"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","sourcesContent":["function isArray(text) {\n    return Array.isArray(text);\n}\nfunction insertNewlineAtPosition(position, arrayOfStrings) {\n    const { indexToInsertInto, localPosition } = arrayOfStrings.reduce(({ indexToInsertInto, localPosition, lengthOfPreceding }, string, i) => {\n        const totalLength = string.length + lengthOfPreceding;\n        if (!indexToInsertInto && !localPosition && position < totalLength) {\n            return {\n                indexToInsertInto: i,\n                localPosition: position - lengthOfPreceding,\n                lengthOfPreceding: totalLength\n            };\n        }\n        return {\n            indexToInsertInto,\n            localPosition,\n            lengthOfPreceding: totalLength\n        };\n    }, { indexToInsertInto: 0, localPosition: 0, lengthOfPreceding: 0 });\n    return (arrayOfStrings\n        .map((string, i) => {\n        if (i === indexToInsertInto) {\n            return (string.slice(0, localPosition) + \"\\n\" + string.slice(localPosition));\n        }\n        return string;\n    })\n        // This is to remove whitespace adjacent to newlines, but to preserve starting or trailing whitespace\n        .map(string => string\n        .split(\"\\n\")\n        .map((str, i, strs) => {\n        if (i < strs.length - 2 && i > 0) {\n            return str.trim();\n        }\n        if (i < strs.length - 2) {\n            return str.trimRight();\n        }\n        else if (i > 0) {\n            return str.trimLeft();\n        }\n        return str;\n    })\n        .join(\"\\n\")));\n}\nfunction breakLines(text, width, font) {\n    const supportsOffscreenCanvas = \"OffscreenCanvas\" in window;\n    const canvasEl = document.createElement(\"canvas\");\n    const canvas = supportsOffscreenCanvas\n        ? canvasEl.transferControlToOffscreen()\n        : canvasEl;\n    canvas.width = width;\n    const ctx = canvas.getContext(\"2d\");\n    if (ctx) {\n        ctx.font = font;\n        const brokenWords = text.split(\" \").reduce((accumulator, word) => {\n            // get the last element of the accumulator\n            const [lastLine] = accumulator.slice(-1);\n            // add the word to it\n            const maybeNextLine = [...lastLine, word].join(\" \");\n            // see if it fits within the width\n            let { width: textWidth } = ctx.measureText(maybeNextLine);\n            // if it does, append to the last element\n            if (textWidth <= width) {\n                return [...accumulator.slice(0, -1), [...lastLine, word]];\n            }\n            if (lastLine.length === 0) {\n                return [...accumulator.slice(0, -1), [word]];\n            }\n            // if not, create a new array containing the word as the last element\n            return [...accumulator, [word]];\n        }, [[]]);\n        return brokenWords.map(line => line.join(\" \")).join(\"\\n\");\n    }\n    console.warn(\"No canvas context was found, so the string was left as is!\");\n    return text;\n}\n/**\n * Breaks a string into lines given a width and style for the text.\n *\n * @param string - The text to be broken into lines\n * @param width - The width in pixels for the text to fit into\n * @param font - The style of the text expressed as a value of the CSS font property, e.g. '12pt bold serif'\n * @returns The given string with newlines inserted\n */\nfunction breakLinesEntry(text, width, font) {\n    if (isArray(text)) {\n        /*\n          ['hello there ', 'my good friend, ', 'how are you today?']\n        + ['hello there my good\\n friend, how are you\\n today?']\n        = ['hello there ', 'my good\\n friend, ', 'how are you\\n today?']\n        */\n        const withNewLines = breakLines(text.join(\"\"), width, font);\n        const newLinePositions = withNewLines\n            .split(\"\")\n            .reduce((positions, char, i) => {\n            if (char === \"\\n\") {\n                return [...positions, i];\n            }\n            return positions;\n        }, []);\n        return newLinePositions.reduce((result, position) => {\n            return insertNewlineAtPosition(position, result);\n        }, text);\n    }\n    return breakLines(text, width, font);\n}\nexport default breakLinesEntry;\n"]},"metadata":{},"sourceType":"module"}