{"ast":null,"code":"import React, { useReducer, useRef, useCallback, useEffect, useMemo, useContext, isValidElement } from 'react';\nimport breakLines from 'break-styled-lines';\n\nfunction isPlayedWindup(windup) {\n  return windup.length === 2;\n}\n\nfunction memberIsWindup(member) {\n  // If it's not an array it can't be a windup\n  if (!Array.isArray(member)) {\n    return false;\n  } // If it has less or more than three members it's not a windup\n\n\n  if (member.length !== 3) {\n    return false;\n  } // If its first or second members are not arrays it's not a windup\n\n\n  if (!Array.isArray(member[0]) || !Array.isArray(member[1])) {\n    return false;\n  } // Past here we just have to hope ElementType isn't a windup.\n\n\n  return true;\n}\n\nfunction windupFromString(str, metadata) {\n  return [[], str.split(\"\"), metadata];\n}\n\nfunction newWindup(arg, metadata) {\n  return [[], arg, metadata];\n}\n\nfunction isUnplayed(windup) {\n  const [played, remaining] = windup;\n\n  if (played.length > 0) {\n    return false;\n  }\n\n  return remaining.reduce((unplayed, member) => {\n    if (memberIsWindup(member)) if (memberIsWindup(windup) && unplayed) {\n      return isUnplayed(member);\n    }\n    return unplayed;\n  }, true);\n}\n\nfunction isFinished([_played, remaining]) {\n  return remaining.length === 0;\n}\n\nfunction fastForward(windup) {\n  const forwardedWindup = next(windup);\n\n  if (isFinished(forwardedWindup)) {\n    return forwardedWindup;\n  }\n\n  return fastForward(forwardedWindup);\n}\n\nfunction rewind(windup) {\n  if (isUnplayed(windup)) {\n    return windup;\n  }\n\n  const [played, remaining, metadata] = windup;\n\n  const mapRewind = member => {\n    if (memberIsWindup(member)) {\n      return rewind(member);\n    }\n\n    return member;\n  };\n\n  return [[], [...played.map(mapRewind), ...remaining.map(mapRewind)], metadata];\n}\n\nfunction lastPlayedMember([played, remaining]) {\n  const playedFromRemaining = remaining.reduce((playedEl, member) => {\n    if (memberIsWindup(member)) {\n      if (!isUnplayed(member)) {\n        return lastPlayedElement(member);\n      }\n    }\n\n    return playedEl;\n  }, undefined);\n\n  if (playedFromRemaining) {\n    return playedFromRemaining;\n  }\n\n  const last = played[played.length - 1];\n  return last;\n}\n\nfunction lastPlayedElement(windup) {\n  const lastPlayed = lastPlayedMember(windup);\n\n  if (memberIsWindup(lastPlayed)) {\n    return lastPlayedElement(lastPlayed);\n  }\n\n  return lastPlayed;\n}\n\nfunction playedElements([played, remaining]) {\n  const playedTransformed = played.map(member => {\n    if (memberIsWindup(member)) {\n      const [_played, _remaining, metadata] = member;\n      return [playedElements(member), metadata];\n    }\n\n    return member;\n  });\n  const [firstRemaning] = remaining;\n\n  if (memberIsWindup(firstRemaning) && !isUnplayed(firstRemaning)) {\n    const [_playedRemaining, _remaining, metadata] = firstRemaning;\n    return [...playedTransformed, [playedElements(firstRemaning), metadata]];\n  }\n\n  return playedTransformed;\n}\n\nfunction nextElement([_played, remaining]) {\n  const [nextVal] = remaining;\n\n  if (memberIsWindup(nextVal)) {\n    return nextElement(nextVal);\n  }\n\n  return nextVal;\n}\n\nfunction next(windup) {\n  // start\n  // [[], [[[], [\"h\", \"i\"]], [[], [\"n\", \"o\"]]]]\n  // next\n  // [[], [[[\"h\"], [\"i\"]], [\"\", [\"n\", \"o\"]]]]\n  // next\n  // [[\"h\", \"i\"], [[\"n\", \"o\"]]]\n  // next\n  // [[\"h\", \"i\"] [\"n\", \"o\"]], []]\n  if (isFinished(windup)) {\n    return windup;\n  }\n\n  const [played, remaining, metadata] = windup;\n  const [firstRemaining, ...restRemaining] = remaining;\n\n  if (memberIsWindup(firstRemaining)) {\n    const nextFirstRemaining = next(firstRemaining);\n\n    if (isFinished(nextFirstRemaining)) {\n      return [[...played, nextFirstRemaining], restRemaining, metadata];\n    }\n\n    return [played, [nextFirstRemaining, ...restRemaining], metadata];\n  }\n\n  return [[...played, firstRemaining], restRemaining, metadata];\n}\n\nfunction defaultGetPace(lastChar, nextChar) {\n  switch (lastChar) {\n    case \"—\":\n    case \"…\":\n      return 200;\n\n    case \".\":\n    case \",\":\n      return 150;\n\n    case \"?\":\n    case \"!\":\n      if (nextChar !== \"!\" && nextChar !== \"?\") {\n        return 150;\n      }\n\n    case \"-\":\n    case \" \":\n    case \"\\n\":\n      return 0;\n\n    default:\n      return 20;\n  }\n}\n\nconst Pace = ({\n  children\n}) => {\n  return React.createElement(React.Fragment, null, children);\n};\n\nfunction isPaceElement(element) {\n  return element.type === Pace;\n}\n\nfunction isMsProp(props) {\n  if (\"ms\" in props) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction paceFromWindup(windup) {\n  if (isFinished(windup)) {\n    return undefined;\n  }\n\n  const [_played, remaining, metadata] = windup;\n  const [firstRemaining] = remaining;\n\n  if (firstRemaining && memberIsWindup(firstRemaining)) {\n    return paceFromWindup(firstRemaining);\n  }\n\n  return metadata.pace;\n}\n\nconst OnChar = ({\n  children\n}) => {\n  return React.createElement(React.Fragment, null, children);\n};\n\nfunction isOnCharElement(element) {\n  return element.type === OnChar;\n} // Should return onChars from\n// every just played member that is a windup\n// any first remaining that is played\n\n\nfunction onCharsFromWindup(windup) {\n  const [_played, remaining, metadata] = windup;\n  const lastPlayed = lastPlayedMember(windup);\n  const [firstRemaining] = remaining;\n  let onChars = [];\n\n  if (lastPlayed && memberIsWindup(lastPlayed)) {\n    onChars.push(...onCharsFromWindup(lastPlayed));\n  }\n\n  if (firstRemaining && memberIsWindup(firstRemaining) && !isUnplayed(firstRemaining)) {\n    onChars.push(...onCharsFromWindup(firstRemaining));\n  }\n\n  if (metadata.onChar) {\n    onChars.push(metadata.onChar);\n  }\n\n  return onChars;\n}\n\nfunction initWindupState(windup) {\n  return {\n    windup,\n    didFinishOnce: false\n  };\n}\n\nfunction windupReducer(state, action) {\n  switch (action.type) {\n    case \"replace\":\n      return initWindupState(action.windup);\n\n    case \"next\":\n      return { ...state,\n        windup: next(state.windup)\n      };\n\n    case \"rewind\":\n      return {\n        windup: rewind(state.windup),\n        didFinishOnce: false\n      };\n\n    case \"fast-forward\":\n      return { ...state,\n        windup: fastForward(state.windup)\n      };\n\n    case \"finish\":\n      return { ...state,\n        didFinishOnce: true\n      };\n\n    default:\n      return state;\n  }\n}\n\nfunction useWindup(windupInit, options) {\n  const [{\n    windup,\n    didFinishOnce\n  }, dispatch] = useReducer(windupReducer, windupInit, initWindupState);\n  const timeoutRef = useRef(null);\n  const windupIsFinished = isFinished(windup);\n  const skip = useCallback(() => {\n    if (!windupIsFinished) {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n  }, [windupIsFinished]);\n  const rewind = useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    dispatch({\n      type: \"rewind\"\n    });\n  }, []); // If windup arg changes, we should reset\n\n  useEffect(() => {\n    dispatch({\n      type: \"replace\",\n      windup: windupInit\n    });\n  }, [windupInit]); // If skipped is changes to true, we should skip\n  // And if it's changed to false, we should restart\n\n  useEffect(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    if (options.skipped) {\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n\n    if (options.skipped === false) {\n      dispatch({\n        type: \"rewind\"\n      });\n    }\n  }, [options.skipped]); // When the windup changes, onChar should fire\n\n  useEffect(() => {\n    const onChars = onCharsFromWindup(windup);\n    const lastEl = lastPlayedElement(windup);\n\n    if (onChars.length > 0 && lastEl) {\n      onChars.forEach(onChar => {\n        onChar(lastEl);\n      });\n    }\n  }, [windup]); // If windup finishes, the onFinished should fire\n\n  useEffect(() => {\n    // Put this in a new context so that the windup finishes visually before firing this\n    if (didFinishOnce === false && windupIsFinished) {\n      const timeout = setTimeout(() => {\n        if (options.onFinished) {\n          options.onFinished();\n        }\n\n        dispatch({\n          type: \"finish\"\n        });\n      }, 0);\n      return () => {\n        clearTimeout(timeout);\n      };\n    }\n  }, [didFinishOnce, windupIsFinished, options]); // the windup effect itself\n\n  useEffect(() => {\n    if (!windupIsFinished) {\n      const getPace = paceFromWindup(windup) || defaultGetPace;\n      const lastEl = lastPlayedElement(windup);\n      const nextEl = nextElement(windup);\n      timeoutRef.current = setTimeout(() => {\n        dispatch({\n          type: \"next\"\n        });\n      }, lastEl ? getPace(lastEl, nextEl) : 0);\n      return () => {\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n        }\n      };\n    }\n  }, [windup, windupIsFinished]);\n  return {\n    windup,\n    skip,\n    rewind,\n    isFinished: windupIsFinished\n  };\n}\n\nfunction renderStringWindup(windup) {\n  const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n  const inner = played.reduce((acc, playedEl) => {\n    if (typeof playedEl === \"string\") {\n      return acc + playedEl;\n    }\n\n    return acc + renderStringWindup(playedEl);\n  }, \"\");\n  return inner;\n}\n\nconst VOID_TAGS = [\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"];\n\nfunction renderChildrenWindup(windup) {\n  const metadata = isPlayedWindup(windup) ? windup[1] : windup[2];\n  const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n  const Outer = metadata.element || React.Fragment;\n\n  if (metadata.props && Object.keys(metadata.props).includes(\"children\")) {\n    return React.createElement(Outer, Object.assign({}, metadata.props));\n  }\n\n  const inner = played.reduce((acc, playedEl) => {\n    if (typeof playedEl === \"string\") {\n      const accButLast = acc.slice(0, acc.length - 1);\n      const last = acc[acc.length - 1];\n      return last && typeof last === \"string\" ? [...accButLast, last + playedEl] : [...acc, playedEl];\n    }\n\n    return [...acc, renderChildrenWindup(playedEl)];\n  }, []);\n\n  if (typeof metadata.element === \"string\" && VOID_TAGS.includes(metadata.element)) {\n    return React.createElement(Outer, Object.assign({\n      key: metadata.key\n    }, metadata.props));\n  }\n\n  return React.createElement(Outer, Object.assign({\n    key: metadata.key\n  }, metadata.props), inner);\n}\n\nfunction useWindupString(text, options = {}) {\n  const windupInit = useMemo(() => {\n    return windupFromString(text, options);\n  }, [text]);\n  const {\n    windup,\n    skip,\n    rewind,\n    isFinished\n  } = useWindup(windupInit, options);\n  return [renderStringWindup(windup), {\n    skip,\n    rewind,\n    isFinished\n  }];\n}\n\nconst Pause = ({}) => {\n  return null;\n};\n\nfunction isPauseElement(element) {\n  return element.type === Pause;\n}\n\nconst WindupContext = React.createContext({\n  skip: () => {\n    console.warn(\"Tried to use the useSkip hook outside of a WindupChildren component!!\");\n  },\n  rewind: () => {\n    console.warn(\"Tried to use the useRewind hook outside of a WindupChildren component!\");\n  },\n  isFinished: false\n});\n\nfunction useSkip() {\n  const {\n    skip\n  } = useContext(WindupContext);\n  return skip;\n}\n\nfunction useRewind() {\n  const {\n    rewind\n  } = useContext(WindupContext);\n  return rewind;\n}\n\nfunction useIsFinished() {\n  const {\n    isFinished\n  } = useContext(WindupContext);\n  return isFinished;\n}\n\nfunction reduceWindupArgs(prevArgs, children) {\n  if (typeof children === \"string\") {\n    return [...prevArgs, ...children.split(\"\")];\n  }\n\n  if (typeof children === \"number\") {\n    return [...prevArgs, ...children.toString().split(\"\")];\n  }\n\n  if (!React.isValidElement(children)) {\n    return prevArgs;\n  }\n\n  const {\n    children: childrenChildren,\n    ...restProps\n  } = children.props;\n  const paceMetaData = isPaceElement(children) ? {\n    pace: char => {\n      if (isMsProp(children.props)) {\n        return children.props.ms;\n      }\n\n      return children.props.getPace(char);\n    }\n  } : {};\n  const onCharMetaData = isOnCharElement(children) ? {\n    onChar: children.props.fn\n  } : {};\n  const keyProp = children.key ? {\n    key: children.key\n  } : {};\n\n  if (isPauseElement(children)) {\n    return [...prevArgs, windupFromString(\" \", {\n      element: React.Fragment,\n      ...keyProp,\n      props: {},\n      pace: () => children.props.ms\n    })];\n  }\n\n  if (childrenChildren === undefined) {\n    return [...prevArgs, windupFromString(\" \", {\n      element: children.type,\n      props: restProps,\n      ...keyProp,\n      ...paceMetaData,\n      ...onCharMetaData\n    })];\n  }\n\n  if (typeof childrenChildren === \"string\") {\n    return [...prevArgs, windupFromString(childrenChildren, {\n      element: children.type,\n      props: restProps,\n      ...keyProp,\n      ...paceMetaData,\n      ...onCharMetaData\n    })];\n  }\n\n  if (childrenChildren instanceof Function) {\n    return [...prevArgs, windupFromString(\" \", {\n      element: children.type,\n      props: {\n        children: childrenChildren,\n        ...restProps\n      },\n      ...keyProp,\n      ...paceMetaData,\n      ...onCharMetaData\n    })];\n  }\n\n  const newArgs = React.Children.toArray(childrenChildren).reduce(reduceWindupArgs, []);\n  const argsWithMetadata = newArgs.map(member => {\n    if (memberIsWindup(member)) {\n      const [played, remaining, metadata] = member;\n      return [played, remaining, { ...paceMetaData,\n        ...onCharMetaData,\n        ...metadata\n      }];\n    }\n\n    return member;\n  });\n  return [...prevArgs, newWindup(argsWithMetadata, {\n    element: children.type,\n    props: restProps,\n    ...keyProp,\n    ...paceMetaData,\n    ...onCharMetaData\n  })];\n}\n\nfunction buildKeyString(children) {\n  if (children === null || children === undefined) {\n    return \"\";\n  }\n\n  return React.Children.map(children, child => {\n    if (typeof child === \"string\") {\n      return child;\n    }\n\n    if (typeof child === \"number\") {\n      return child.toString();\n    }\n\n    if (React.isValidElement(child)) {\n      return `#${child.key || \"\"}<${buildKeyString(child.props.children)}>`;\n    }\n\n    return \"\";\n  }).join(\",\");\n}\n\nfunction useChildrenMemo(factory, children) {\n  const memoChildren = useMemo(factory, [buildKeyString(children)]);\n  return memoChildren;\n}\n\nconst WindupChildren = ({\n  children,\n  onFinished,\n  skipped\n}) => {\n  const windupInit = useChildrenMemo(() => {\n    return newWindup(React.Children.toArray(children).reduce(reduceWindupArgs, []), {\n      element: undefined\n    });\n  }, children);\n  const {\n    windup,\n    skip,\n    rewind,\n    isFinished\n  } = useWindup(windupInit, {\n    onFinished,\n    skipped\n  });\n  return React.createElement(WindupContext.Provider, {\n    value: {\n      skip,\n      rewind,\n      isFinished\n    }\n  }, renderChildrenWindup(windup));\n};\n\nfunction wrapChildren(children, Wrapper) {\n  if (typeof children === \"string\") {\n    return children.split(\"\").map((char, i) => char === \"\\n\" ? char : React.createElement(Wrapper, {\n      key: `${char}-${i}`\n    }, char));\n  }\n\n  if (typeof children === \"number\") {\n    return children.toString().split(\"\").map(char => React.createElement(Wrapper, null, char));\n  }\n\n  if (!React.isValidElement(children)) {\n    return React.createElement(React.Fragment, null);\n  }\n\n  if (children.props.children) {\n    const Outer = children.type;\n\n    if (children.props.children instanceof Function) {\n      return React.createElement(Outer, Object.assign({\n        key: children.key\n      }, children.props));\n    }\n\n    return React.createElement(Outer, Object.assign({\n      key: children.key\n    }, children.props), React.Children.map(children.props.children, ch => {\n      return wrapChildren(ch, Wrapper);\n    }));\n  }\n\n  return children;\n}\n\nconst CharWrapper = ({\n  children,\n  element\n}) => {\n  return React.createElement(React.Fragment, null, React.Children.map(children, ch => {\n    return wrapChildren(ch, element);\n  }));\n};\n\nfunction getStringsOfReactChildren(strings, children) {\n  if (typeof children === \"string\") {\n    return [...strings, children];\n  }\n\n  if (typeof children === \"number\") {\n    return [...strings, children.toString()];\n  }\n\n  if (!React.isValidElement(children)) {\n    return strings;\n  }\n\n  return [...strings, ...React.Children.toArray(children.props.children).reduce(getStringsOfReactChildren, [])];\n}\n\nfunction reinsertStringsIntoChildren([accChildren, accStrings], children) {\n  if (typeof children === \"string\" || typeof children === \"number\") {\n    const [firstString, ...restStrings] = accStrings;\n    return [[...accChildren, firstString], restStrings];\n  }\n\n  if (!React.isValidElement(children)) {\n    return [accChildren, accStrings];\n  }\n\n  const [subChildrenAcc, subStringsAcc] = React.Children.toArray(children.props.children).reduce(reinsertStringsIntoChildren, [[], accStrings]);\n  return [[...accChildren, React.cloneElement(children, {\n    children: subChildrenAcc\n  })], subStringsAcc];\n}\n\nconst Linebreaker = ({\n  children,\n  fontStyle,\n  width\n}) => {\n  // CAVEATS:\n  // fontStyle must match the font style of the characters inside\n  // non-character elements must not add width to the line.\n  // must be used OUTSIDE of WindupChildren component\n  const childrenArray = React.Children.toArray(children);\n  const strings = childrenArray.reduce(getStringsOfReactChildren, []);\n  const transformedStrings = breakLines(strings, width, fontStyle);\n  const [transformedChildren] = childrenArray.reduce(reinsertStringsIntoChildren, [[], transformedStrings]);\n  return React.createElement(\"div\", {\n    style: {\n      whiteSpace: \"pre\"\n    }\n  }, transformedChildren);\n};\n\nconst Effect = ({\n  fn\n}) => {\n  useEffect(() => {\n    fn();\n  }, []);\n  return null;\n};\n\nfunction textFromChildren(children) {\n  return React.Children.map(children, ch => {\n    if (typeof ch === \"string\") {\n      return ch;\n    }\n\n    if (typeof ch === \"number\") {\n      return ch.toString();\n    }\n\n    if (!isValidElement(ch)) {\n      return \"\";\n    }\n\n    if (ch.props.children) {\n      return textFromChildren(ch.props.children);\n    }\n\n    return \"\";\n  }).join(\"\");\n}\n\nexport { CharWrapper, Effect, Linebreaker, OnChar, Pace, Pause, WindupChildren, defaultGetPace, textFromChildren, useIsFinished, useRewind, useSkip, useWindupString };","map":{"version":3,"sources":["../dist-src/Windup.js","../dist-src/react/Pace.js","../dist-src/react/OnChar.js","../dist-src/react/useWindup.js","../dist-src/react/renderWindup.js","../dist-src/react/useWindupString.js","../dist-src/react/Pause.js","../dist-src/react/WindupChildren.js","../dist-src/react/CharWrapper.js","../dist-src/react/Linebreaker.js","../dist-src/react/Effect.js","../dist-src/react/textFromChildren.js"],"names":[],"mappings":"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","sourcesContent":["export function isPlayedWindup(windup) {\n    return windup.length === 2;\n}\nexport function memberIsWindup(member) {\n    // If it's not an array it can't be a windup\n    if (!Array.isArray(member)) {\n        return false;\n    }\n    // If it has less or more than three members it's not a windup\n    if (member.length !== 3) {\n        return false;\n    }\n    // If its first or second members are not arrays it's not a windup\n    if (!Array.isArray(member[0]) || !Array.isArray(member[1])) {\n        return false;\n    }\n    // Past here we just have to hope ElementType isn't a windup.\n    return true;\n}\nexport function windupFromString(str, metadata) {\n    return [[], str.split(\"\"), metadata];\n}\nexport function newWindup(arg, metadata) {\n    return [[], arg, metadata];\n}\nexport function isUnplayed(windup) {\n    const [played, remaining] = windup;\n    if (played.length > 0) {\n        return false;\n    }\n    return remaining.reduce((unplayed, member) => {\n        if (memberIsWindup(member))\n            if (memberIsWindup(windup) && unplayed) {\n                return isUnplayed(member);\n            }\n        return unplayed;\n    }, true);\n}\nexport function isFinished([_played, remaining,]) {\n    return remaining.length === 0;\n}\nexport function fastForward(windup) {\n    const forwardedWindup = next(windup);\n    if (isFinished(forwardedWindup)) {\n        return forwardedWindup;\n    }\n    return fastForward(forwardedWindup);\n}\nexport function rewind(windup) {\n    if (isUnplayed(windup)) {\n        return windup;\n    }\n    const [played, remaining, metadata] = windup;\n    const mapRewind = (member) => {\n        if (memberIsWindup(member)) {\n            return rewind(member);\n        }\n        return member;\n    };\n    return [\n        [],\n        [...played.map(mapRewind), ...remaining.map(mapRewind)],\n        metadata,\n    ];\n}\nexport function windupAsString(windup) {\n    const [played, remaining] = windup;\n    const stringify = (member) => {\n        if (memberIsWindup(member)) {\n            return windupAsString(member);\n        }\n        return member;\n    };\n    return [\n        played.map(stringify).join(\"\"),\n        remaining.map(stringify).join(\"\"),\n    ].join(\"\");\n}\nexport function lastPlayedMember([played, remaining,]) {\n    const playedFromRemaining = remaining.reduce((playedEl, member) => {\n        if (memberIsWindup(member)) {\n            if (!isUnplayed(member)) {\n                return lastPlayedElement(member);\n            }\n        }\n        return playedEl;\n    }, undefined);\n    if (playedFromRemaining) {\n        return playedFromRemaining;\n    }\n    const last = played[played.length - 1];\n    return last;\n}\nexport function lastPlayedElement(windup) {\n    const lastPlayed = lastPlayedMember(windup);\n    if (memberIsWindup(lastPlayed)) {\n        return lastPlayedElement(lastPlayed);\n    }\n    return lastPlayed;\n}\nexport function playedElements([played, remaining,]) {\n    const playedTransformed = played.map((member) => {\n        if (memberIsWindup(member)) {\n            const [_played, _remaining, metadata] = member;\n            return [playedElements(member), metadata];\n        }\n        return member;\n    });\n    const [firstRemaning] = remaining;\n    if (memberIsWindup(firstRemaning) && !isUnplayed(firstRemaning)) {\n        const [_playedRemaining, _remaining, metadata] = firstRemaning;\n        return [\n            ...playedTransformed,\n            [playedElements(firstRemaning), metadata],\n        ];\n    }\n    return playedTransformed;\n}\nexport function nextElement([_played, remaining,]) {\n    const [nextVal] = remaining;\n    if (memberIsWindup(nextVal)) {\n        return nextElement(nextVal);\n    }\n    return nextVal;\n}\nexport function next(windup) {\n    // start\n    // [[], [[[], [\"h\", \"i\"]], [[], [\"n\", \"o\"]]]]\n    // next\n    // [[], [[[\"h\"], [\"i\"]], [\"\", [\"n\", \"o\"]]]]\n    // next\n    // [[\"h\", \"i\"], [[\"n\", \"o\"]]]\n    // next\n    // [[\"h\", \"i\"] [\"n\", \"o\"]], []]\n    if (isFinished(windup)) {\n        return windup;\n    }\n    const [played, remaining, metadata] = windup;\n    const [firstRemaining, ...restRemaining] = remaining;\n    if (memberIsWindup(firstRemaining)) {\n        const nextFirstRemaining = next(firstRemaining);\n        if (isFinished(nextFirstRemaining)) {\n            return [[...played, nextFirstRemaining], restRemaining, metadata];\n        }\n        return [played, [nextFirstRemaining, ...restRemaining], metadata];\n    }\n    return [[...played, firstRemaining], restRemaining, metadata];\n}\n","import React from \"react\";\nimport { isFinished, memberIsWindup } from \"../Windup\";\nexport function defaultGetPace(lastChar, nextChar) {\n    switch (lastChar) {\n        case \"—\":\n        case \"…\":\n            return 200;\n        case \".\":\n        case \",\":\n            return 150;\n        case \"?\":\n        case \"!\":\n            if (nextChar !== \"!\" && nextChar !== \"?\") {\n                return 150;\n            }\n        case \"-\":\n        case \" \":\n        case \"\\n\":\n            return 0;\n        default:\n            return 20;\n    }\n}\nconst Pace = ({ children }) => {\n    return React.createElement(React.Fragment, null, children);\n};\nexport function isPaceElement(element) {\n    return element.type === Pace;\n}\nexport function isMsProp(props) {\n    if (\"ms\" in props) {\n        return true;\n    }\n    return false;\n}\nexport function paceFromWindup(windup) {\n    if (isFinished(windup)) {\n        return undefined;\n    }\n    const [_played, remaining, metadata] = windup;\n    const [firstRemaining] = remaining;\n    if (firstRemaining && memberIsWindup(firstRemaining)) {\n        return paceFromWindup(firstRemaining);\n    }\n    return metadata.pace;\n}\nexport default Pace;\n","import React from \"react\";\nimport { memberIsWindup, lastPlayedMember, isUnplayed } from \"../Windup\";\nconst OnChar = ({ children }) => {\n    return React.createElement(React.Fragment, null, children);\n};\nexport function isOnCharElement(element) {\n    return element.type === OnChar;\n}\n// Should return onChars from\n// every just played member that is a windup\n// any first remaining that is played\nexport function onCharsFromWindup(windup) {\n    const [_played, remaining, metadata] = windup;\n    const lastPlayed = lastPlayedMember(windup);\n    const [firstRemaining] = remaining;\n    let onChars = [];\n    if (lastPlayed && memberIsWindup(lastPlayed)) {\n        onChars.push(...onCharsFromWindup(lastPlayed));\n    }\n    if (firstRemaining &&\n        memberIsWindup(firstRemaining) &&\n        !isUnplayed(firstRemaining)) {\n        onChars.push(...onCharsFromWindup(firstRemaining));\n    }\n    if (metadata.onChar) {\n        onChars.push(metadata.onChar);\n    }\n    return onChars;\n}\nexport default OnChar;\n","import { useRef, useEffect, useCallback, useReducer } from \"react\";\nimport { defaultGetPace, paceFromWindup } from \"./Pace\";\nimport { isFinished, lastPlayedElement, next, fastForward, rewind, nextElement, } from \"../Windup\";\nimport { onCharsFromWindup } from \"./OnChar\";\nfunction initWindupState(windup) {\n    return { windup, didFinishOnce: false };\n}\nfunction windupReducer(state, action) {\n    switch (action.type) {\n        case \"replace\":\n            return initWindupState(action.windup);\n        case \"next\":\n            return { ...state, windup: next(state.windup) };\n        case \"rewind\":\n            return { windup: rewind(state.windup), didFinishOnce: false };\n        case \"fast-forward\":\n            return { ...state, windup: fastForward(state.windup) };\n        case \"finish\":\n            return { ...state, didFinishOnce: true };\n        default:\n            return state;\n    }\n}\nexport default function useWindup(windupInit, options) {\n    const [{ windup, didFinishOnce }, dispatch] = useReducer(windupReducer, windupInit, initWindupState);\n    const timeoutRef = useRef(null);\n    const windupIsFinished = isFinished(windup);\n    const skip = useCallback(() => {\n        if (!windupIsFinished) {\n            if (timeoutRef.current) {\n                clearTimeout(timeoutRef.current);\n            }\n            dispatch({\n                type: \"fast-forward\",\n            });\n        }\n    }, [windupIsFinished]);\n    const rewind = useCallback(() => {\n        if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n        }\n        dispatch({ type: \"rewind\" });\n    }, []);\n    // If windup arg changes, we should reset\n    useEffect(() => {\n        dispatch({ type: \"replace\", windup: windupInit });\n    }, [windupInit]);\n    // If skipped is changes to true, we should skip\n    // And if it's changed to false, we should restart\n    useEffect(() => {\n        if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n        }\n        if (options.skipped) {\n            dispatch({\n                type: \"fast-forward\",\n            });\n        }\n        if (options.skipped === false) {\n            dispatch({ type: \"rewind\" });\n        }\n    }, [options.skipped]);\n    // When the windup changes, onChar should fire\n    useEffect(() => {\n        const onChars = onCharsFromWindup(windup);\n        const lastEl = lastPlayedElement(windup);\n        if (onChars.length > 0 && lastEl) {\n            onChars.forEach((onChar) => {\n                onChar(lastEl);\n            });\n        }\n    }, [windup]);\n    // If windup finishes, the onFinished should fire\n    useEffect(() => {\n        // Put this in a new context so that the windup finishes visually before firing this\n        if (didFinishOnce === false && windupIsFinished) {\n            const timeout = setTimeout(() => {\n                if (options.onFinished) {\n                    options.onFinished();\n                }\n                dispatch({ type: \"finish\" });\n            }, 0);\n            return () => {\n                clearTimeout(timeout);\n            };\n        }\n    }, [didFinishOnce, windupIsFinished, options]);\n    // the windup effect itself\n    useEffect(() => {\n        if (!windupIsFinished) {\n            const getPace = paceFromWindup(windup) || defaultGetPace;\n            const lastEl = lastPlayedElement(windup);\n            const nextEl = nextElement(windup);\n            timeoutRef.current = setTimeout(() => {\n                dispatch({ type: \"next\" });\n            }, lastEl ? getPace(lastEl, nextEl) : 0);\n            return () => {\n                if (timeoutRef.current) {\n                    clearTimeout(timeoutRef.current);\n                }\n            };\n        }\n    }, [windup, windupIsFinished]);\n    return {\n        windup,\n        skip,\n        rewind,\n        isFinished: windupIsFinished,\n    };\n}\n","import React from \"react\";\nimport { playedElements, isPlayedWindup } from \"../Windup\";\nexport function renderStringWindup(windup) {\n    const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n    const inner = played.reduce((acc, playedEl) => {\n        if (typeof playedEl === \"string\") {\n            return acc + playedEl;\n        }\n        return acc + renderStringWindup(playedEl);\n    }, \"\");\n    return inner;\n}\nconst VOID_TAGS = [\n    \"area\",\n    \"base\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\"\n];\nexport function renderChildrenWindup(windup) {\n    const metadata = isPlayedWindup(windup) ? windup[1] : windup[2];\n    const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n    const Outer = metadata.element || React.Fragment;\n    if (metadata.props && Object.keys(metadata.props).includes(\"children\")) {\n        return React.createElement(Outer, Object.assign({}, metadata.props));\n    }\n    const inner = played.reduce((acc, playedEl) => {\n        if (typeof playedEl === \"string\") {\n            const accButLast = acc.slice(0, acc.length - 1);\n            const last = acc[acc.length - 1];\n            return last && typeof last === \"string\"\n                ? [...accButLast, last + playedEl]\n                : [...acc, playedEl];\n        }\n        return [...acc, renderChildrenWindup(playedEl)];\n    }, []);\n    if (typeof metadata.element === \"string\" &&\n        VOID_TAGS.includes(metadata.element)) {\n        return React.createElement(Outer, Object.assign({ key: metadata.key }, metadata.props));\n    }\n    return (React.createElement(Outer, Object.assign({ key: metadata.key }, metadata.props), inner));\n}\n","import { useMemo } from \"react\";\nimport { windupFromString } from \"../Windup\";\nimport useWindup from \"./useWindup\";\nimport { renderStringWindup } from \"./renderWindup\";\nexport default function useWindupString(text, options = {}) {\n    const windupInit = useMemo(() => {\n        return windupFromString(text, options);\n    }, [text]);\n    const { windup, skip, rewind, isFinished } = useWindup(windupInit, options);\n    return [renderStringWindup(windup), { skip, rewind, isFinished }];\n}\n","const Pause = ({}) => {\n    return null;\n};\nexport function isPauseElement(element) {\n    return element.type === Pause;\n}\nexport default Pause;\n","import React, { useContext, useMemo } from \"react\";\nimport { newWindup, windupFromString, memberIsWindup } from \"../Windup\";\nimport { isPaceElement, isMsProp } from \"./Pace\";\nimport { isOnCharElement } from \"./OnChar\";\nimport { isPauseElement } from \"./Pause\";\nimport useWindup from \"./useWindup\";\nimport { renderChildrenWindup } from \"./renderWindup\";\nconst WindupContext = React.createContext({\n    skip: () => {\n        console.warn(\"Tried to use the useSkip hook outside of a WindupChildren component!!\");\n    },\n    rewind: () => {\n        console.warn(\"Tried to use the useRewind hook outside of a WindupChildren component!\");\n    },\n    isFinished: false\n});\nexport function useSkip() {\n    const { skip } = useContext(WindupContext);\n    return skip;\n}\nexport function useRewind() {\n    const { rewind } = useContext(WindupContext);\n    return rewind;\n}\nexport function useIsFinished() {\n    const { isFinished } = useContext(WindupContext);\n    return isFinished;\n}\nfunction reduceWindupArgs(prevArgs, children) {\n    if (typeof children === \"string\") {\n        return [...prevArgs, ...children.split(\"\")];\n    }\n    if (typeof children === \"number\") {\n        return [...prevArgs, ...children.toString().split(\"\")];\n    }\n    if (!React.isValidElement(children)) {\n        return prevArgs;\n    }\n    const { children: childrenChildren, ...restProps } = children.props;\n    const paceMetaData = isPaceElement(children)\n        ? {\n            pace: (char) => {\n                if (isMsProp(children.props)) {\n                    return children.props.ms;\n                }\n                return children.props.getPace(char);\n            }\n        }\n        : {};\n    const onCharMetaData = isOnCharElement(children)\n        ? {\n            onChar: children.props.fn\n        }\n        : {};\n    const keyProp = children.key ? { key: children.key } : {};\n    if (isPauseElement(children)) {\n        return [\n            ...prevArgs,\n            windupFromString(\" \", {\n                element: React.Fragment,\n                ...keyProp,\n                props: {},\n                pace: () => children.props.ms\n            })\n        ];\n    }\n    if (childrenChildren === undefined) {\n        return [\n            ...prevArgs,\n            windupFromString(\" \", {\n                element: children.type,\n                props: restProps,\n                ...keyProp,\n                ...paceMetaData,\n                ...onCharMetaData\n            })\n        ];\n    }\n    if (typeof childrenChildren === \"string\") {\n        return [\n            ...prevArgs,\n            windupFromString(childrenChildren, {\n                element: children.type,\n                props: restProps,\n                ...keyProp,\n                ...paceMetaData,\n                ...onCharMetaData\n            })\n        ];\n    }\n    if (childrenChildren instanceof Function) {\n        return [\n            ...prevArgs,\n            windupFromString(\" \", {\n                element: children.type,\n                props: { children: childrenChildren, ...restProps },\n                ...keyProp,\n                ...paceMetaData,\n                ...onCharMetaData\n            })\n        ];\n    }\n    const newArgs = React.Children.toArray(childrenChildren).reduce(reduceWindupArgs, []);\n    const argsWithMetadata = newArgs.map(member => {\n        if (memberIsWindup(member)) {\n            const [played, remaining, metadata] = member;\n            return [\n                played,\n                remaining,\n                {\n                    ...paceMetaData,\n                    ...onCharMetaData,\n                    ...metadata\n                }\n            ];\n        }\n        return member;\n    });\n    return [\n        ...prevArgs,\n        newWindup(argsWithMetadata, {\n            element: children.type,\n            props: restProps,\n            ...keyProp,\n            ...paceMetaData,\n            ...onCharMetaData\n        })\n    ];\n}\nfunction buildKeyString(children) {\n    if (children === null || children === undefined) {\n        return \"\";\n    }\n    return React.Children.map(children, child => {\n        if (typeof child === \"string\") {\n            return child;\n        }\n        if (typeof child === \"number\") {\n            return child.toString();\n        }\n        if (React.isValidElement(child)) {\n            return `#${child.key || \"\"}<${buildKeyString(child.props.children)}>`;\n        }\n        return \"\";\n    }).join(\",\");\n}\nfunction useChildrenMemo(factory, children) {\n    const memoChildren = useMemo(factory, [buildKeyString(children)]);\n    return memoChildren;\n}\nconst WindupChildren = ({ children, onFinished, skipped }) => {\n    const windupInit = useChildrenMemo(() => {\n        return newWindup(React.Children.toArray(children).reduce(reduceWindupArgs, []), { element: undefined });\n    }, children);\n    const { windup, skip, rewind, isFinished } = useWindup(windupInit, {\n        onFinished,\n        skipped\n    });\n    return (React.createElement(WindupContext.Provider, { value: {\n            skip,\n            rewind,\n            isFinished\n        } }, renderChildrenWindup(windup)));\n};\nexport default WindupChildren;\n","import React from \"react\";\nfunction wrapChildren(children, Wrapper) {\n    if (typeof children === \"string\") {\n        return children\n            .split(\"\")\n            .map((char, i) => char === \"\\n\" ? char : React.createElement(Wrapper, { key: `${char}-${i}` }, char));\n    }\n    if (typeof children === \"number\") {\n        return children\n            .toString()\n            .split(\"\")\n            .map(char => React.createElement(Wrapper, null, char));\n    }\n    if (!React.isValidElement(children)) {\n        return React.createElement(React.Fragment, null);\n    }\n    if (children.props.children) {\n        const Outer = children.type;\n        if (children.props.children instanceof Function) {\n            return React.createElement(Outer, Object.assign({ key: children.key }, children.props));\n        }\n        return (React.createElement(Outer, Object.assign({ key: children.key }, children.props), React.Children.map(children.props.children, ch => {\n            return wrapChildren(ch, Wrapper);\n        })));\n    }\n    return children;\n}\nconst CharWrapper = ({ children, element }) => {\n    return (React.createElement(React.Fragment, null, React.Children.map(children, ch => {\n        return wrapChildren(ch, element);\n    })));\n};\nexport default CharWrapper;\n","import React from \"react\";\nimport breakLines from \"break-styled-lines\";\nfunction getStringsOfReactChildren(strings, children) {\n    if (typeof children === \"string\") {\n        return [...strings, children];\n    }\n    if (typeof children === \"number\") {\n        return [...strings, children.toString()];\n    }\n    if (!React.isValidElement(children)) {\n        return strings;\n    }\n    return [\n        ...strings,\n        ...React.Children.toArray(children.props.children).reduce(getStringsOfReactChildren, [])\n    ];\n}\nfunction reinsertStringsIntoChildren([accChildren, accStrings], children) {\n    if (typeof children === \"string\" || typeof children === \"number\") {\n        const [firstString, ...restStrings] = accStrings;\n        return [[...accChildren, firstString], restStrings];\n    }\n    if (!React.isValidElement(children)) {\n        return [accChildren, accStrings];\n    }\n    const [subChildrenAcc, subStringsAcc] = React.Children.toArray(children.props.children).reduce(reinsertStringsIntoChildren, [[], accStrings]);\n    return [\n        [\n            ...accChildren,\n            React.cloneElement(children, {\n                children: subChildrenAcc\n            })\n        ],\n        subStringsAcc\n    ];\n}\nconst Linebreaker = ({ children, fontStyle, width }) => {\n    // CAVEATS:\n    // fontStyle must match the font style of the characters inside\n    // non-character elements must not add width to the line.\n    // must be used OUTSIDE of WindupChildren component\n    const childrenArray = React.Children.toArray(children);\n    const strings = childrenArray.reduce(getStringsOfReactChildren, []);\n    const transformedStrings = breakLines(strings, width, fontStyle);\n    const [transformedChildren] = childrenArray.reduce(reinsertStringsIntoChildren, [\n        [],\n        transformedStrings\n    ]);\n    return React.createElement(\"div\", { style: { whiteSpace: \"pre\" } }, transformedChildren);\n};\nexport default Linebreaker;\n","import { useEffect } from \"react\";\nconst Effect = ({ fn }) => {\n    useEffect(() => {\n        fn();\n    }, []);\n    return null;\n};\nexport default Effect;\n","import React, { isValidElement } from \"react\";\nexport default function textFromChildren(children) {\n    return React.Children.map(children, (ch) => {\n        if (typeof ch === \"string\") {\n            return ch;\n        }\n        if (typeof ch === \"number\") {\n            return ch.toString();\n        }\n        if (!isValidElement(ch)) {\n            return \"\";\n        }\n        if (ch.props.children) {\n            return textFromChildren(ch.props.children);\n        }\n        return \"\";\n    }).join(\"\");\n}\n"]},"metadata":{},"sourceType":"module"}